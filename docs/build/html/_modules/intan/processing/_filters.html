

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>intan.processing._filters &mdash; python-intan 0.0.3 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=47de8214"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            python-intan
              <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intan_api/modules.html">intan</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">python-intan</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">intan.processing._filters</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for intan.processing._filters</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">intan.processing._filters</span>

<span class="sd">Comprehensive EMG signal preprocessing module.</span>

<span class="sd">Includes:</span>
<span class="sd">- Bandpass, lowpass, and notch filters</span>
<span class="sd">- Hilbert envelope extraction</span>
<span class="sd">- RMS and windowed RMS computation</span>
<span class="sd">- Common average referencing (CAR)</span>
<span class="sd">- Sliding windows and PCA-based dimensionality reduction</span>
<span class="sd">- CNN-ECA compatible preprocessing pipeline</span>

<span class="sd">This module supports feature extraction pipelines for real-time classification</span>
<span class="sd">and pre-training EMG datasets with overlapping or fixed windows.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">butter</span><span class="p">,</span> <span class="n">filtfilt</span><span class="p">,</span> <span class="n">hilbert</span><span class="p">,</span> <span class="n">iirnotch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.decomposition</span><span class="w"> </span><span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">StandardScaler</span>


<span class="c1"># Deflationary orthogonality</span>
<div class="viewcode-block" id="orthogonalize">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.orthogonalize">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">orthogonalize</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">wp</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Orthogonalizes the weight vector wp with respect to the first i columns of W.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        W: Weight matrix of shape (n_features, n_features).</span>
<span class="sd">        wp: Weight vector to be orthogonalized of shape (n_features,).</span>
<span class="sd">        i: Index of the column in W to orthogonalize against.</span>

<span class="sd">    Returns:</span>
<span class="sd">        wp: Orthogonalized weight vector of shape (n_features,).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">wp</span> <span class="o">-</span> <span class="p">((</span><span class="n">wp</span> <span class="o">@</span> <span class="n">W</span><span class="p">[:</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">@</span> <span class="n">W</span><span class="p">[:</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span></div>



<span class="c1"># wp normalization</span>
<div class="viewcode-block" id="normalize">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.normalize">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">normalize</span><span class="p">(</span><span class="n">wp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalizes the weight vector wp.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        wp: Weight vector to be normalized of shape (n_features,).</span>

<span class="sd">    Returns:</span>
<span class="sd">        wp: Normalized weight vector of shape (n_features,).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">wp</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span></div>



<div class="viewcode-block" id="preprocess_emg">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.preprocess_emg">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">preprocess_emg</span><span class="p">(</span><span class="n">emg_data</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies filtering and extracts RMS features.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        emg_data: 2D numpy array of EMG data (channels, samples).</span>
<span class="sd">        sample_rate: Sampling rate of the EMG data.</span>

<span class="sd">    Returns:</span>
<span class="sd">        rms_features: 2D numpy array of RMS features (channels, windows).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">notch_filter</span><span class="p">(</span><span class="n">emg_data</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
    <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">bandpass_filter</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">,</span> <span class="n">lowcut</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">highcut</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rms_features</span> <span class="o">=</span> <span class="n">calculate_rms</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rms_features</span></div>



<div class="viewcode-block" id="parse_channel_ranges">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.parse_channel_ranges">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_channel_ranges</span><span class="p">(</span><span class="n">channel_arg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parses a channel range string (e.g., [1:8, 64:72]) and returns a flat list of integers.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        channel_arg (str): The string containing channel ranges (e.g., &quot;[1:8, 64:72]&quot;).</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A flat list of integers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Remove square brackets and split by commas</span>
    <span class="n">channel_arg</span> <span class="o">=</span> <span class="n">channel_arg</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;[]&quot;</span><span class="p">)</span>
    <span class="n">ranges</span> <span class="o">=</span> <span class="n">channel_arg</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>

    <span class="n">channel_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;:&quot;</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">))</span>
            <span class="c1"># channel_list.extend(range(start - 1, end))  # Convert to 0-based indexing</span>
            <span class="n">channel_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># channel_list.append(int(r) - 1)  # Convert single channel to 0-based indexing</span>
            <span class="n">channel_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">channel_list</span></div>



<div class="viewcode-block" id="notch_filter">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.notch_filter">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">notch_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mf">60.0</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a notch filter to the data to remove 60 Hz interference. Assumes data shape (n_channels, n_samples).</span>
<span class="sd">    A bandwidth of 10 Hz is recommended for 50 or 60 Hz notch filters; narrower bandwidths lead to</span>
<span class="sd">    poor time-domain properties with an extended ringing response to</span>
<span class="sd">    transient disturbances.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data (ndarray): Input data to be filtered.</span>
<span class="sd">        fs (float): Sampling frequency of the data.</span>
<span class="sd">        f0 (float): Frequency to be removed from the data (60 Hz).</span>
<span class="sd">        Q (float): Quality factor of the notch filter.</span>

<span class="sd">    Returns:</span>
<span class="sd">        nn.array:</span>

<span class="sd">    Example:</span>
<span class="sd">        out = notch_filter(signal_in, 30000, 60, 10);</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">iirnotch</span><span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>



<div class="viewcode-block" id="lowpass_filter">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.lowpass_filter">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">lowpass_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a lowpass filter to the data using a Butterworth filter.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data (ndarray): Input data to be filtered.</span>
<span class="sd">        cutoff (float): Cutoff frequency.</span>
<span class="sd">        fs (float): Sampling frequency of the data.</span>
<span class="sd">        order (int): Order of the filter.</span>
<span class="sd">        axis (int): Axis along which to apply the filter.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Filtered data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">butter</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s2">&quot;low&quot;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span></div>



<div class="viewcode-block" id="bandpass_filter">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.bandpass_filter">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">bandpass_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">lowcut</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">highcut</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a bandpass filter to the data using a Butterworth filter.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data (ndarray): Input data to be filtered.</span>
<span class="sd">        lowcut (float): Low cutoff frequency.</span>
<span class="sd">        highcut (float): High cutoff frequency.</span>
<span class="sd">        fs (float): Sampling frequency of the data.</span>
<span class="sd">        order (int): Order of the filter.</span>
<span class="sd">        axis (int): Axis along which to apply the filter.</span>
<span class="sd">        verbose (bool): Whether to print filter parameters.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Filtered data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">butter</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="p">[</span><span class="n">lowcut</span><span class="p">,</span> <span class="n">highcut</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s2">&quot;bandpass&quot;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span></div>



<div class="viewcode-block" id="filter_emg">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.filter_emg">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">filter_emg</span><span class="p">(</span><span class="n">emg_data</span><span class="p">,</span> <span class="n">filter_type</span><span class="o">=</span><span class="s1">&#39;bandpass&#39;</span><span class="p">,</span> <span class="n">lowcut</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">highcut</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">1259</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a bandpass or lowpass filter to EMG data using numpy arrays.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        emg_data: Numpy array of shape (num_samples, num_channels) with EMG data.</span>
<span class="sd">        filter_type: Type of filter to apply (&#39;bandpass&#39; or &#39;lowpass&#39;).</span>
<span class="sd">        lowcut: Low cutoff frequency for the bandpass filter.</span>
<span class="sd">        highcut: High cutoff frequency for the bandpass filter.</span>
<span class="sd">        fs: Sampling rate of the EMG data.</span>
<span class="sd">        order: Filter order.</span>
<span class="sd">        verbose: Whether to print progress.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Filtered data as a numpy array (same shape as input data).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s1">&#39;bandpass&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;| Applying butterworth bandpass filter: </span><span class="si">{</span><span class="n">lowcut</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">highcut</span><span class="si">}</span><span class="s2"> Hz </span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2"> order&quot;</span><span class="p">)</span>
        <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">bandpass_filter</span><span class="p">(</span><span class="n">emg_data</span><span class="p">,</span> <span class="n">lowcut</span><span class="p">,</span> <span class="n">highcut</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s1">&#39;lowpass&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;| Applying butterworth lowpass filter: </span><span class="si">{</span><span class="n">lowcut</span><span class="si">}</span><span class="s2"> Hz </span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2"> order&quot;</span><span class="p">)</span>
        <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">lowpass_filter</span><span class="p">(</span><span class="n">emg_data</span><span class="p">,</span> <span class="n">lowcut</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;| | Filtering time = </span><span class="si">{</span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">toc</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tic</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> ms&quot;</span><span class="p">)</span>

    <span class="c1"># Convert list of arrays to a single 2D numpy array</span>
    <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Stack along axis 0 (channels)</span>

    <span class="k">return</span> <span class="n">filtered_data</span></div>



<div class="viewcode-block" id="rectify">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.rectify">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rectify</span><span class="p">(</span><span class="n">emg_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rectifies EMG data by converting all values to their absolute values.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        emg_data (numpy array): List of numpy arrays or pandas DataFrame items with filtered EMG data.</span>

<span class="sd">    Returns:</span>
<span class="sd">        rectified_data: List of rectified numpy arrays (same shape as input data).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">emg_data</span><span class="p">)</span></div>



<div class="viewcode-block" id="window_rms">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.window_rms">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">window_rms</span><span class="p">(</span><span class="n">emg_data</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply windowed RMS to each channel in the multichannel EMG data.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        emg_data: Numpy array of shape (num_samples, num_channels).</span>
<span class="sd">        window_size: Size of the window for RMS calculation.</span>
<span class="sd">        verbose: Whether to print progress.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Smoothed EMG data with windowed RMS applied to each channel (same shape as input).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;| Applying windowed RMS with window size </span><span class="si">{</span><span class="n">window_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">num_channels</span><span class="p">,</span> <span class="n">num_samples</span> <span class="o">=</span> <span class="n">emg_data</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">rms_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_channels</span><span class="p">):</span>
        <span class="n">rms_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">window_rms_1D</span><span class="p">(</span><span class="n">emg_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">window_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rms_data</span></div>



<div class="viewcode-block" id="window_rms_1D">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.window_rms_1D">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">window_rms_1D</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">window_size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute windowed RMS of the signal.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        signal: Input EMG signal.</span>
<span class="sd">        window_size: Size of the window for RMS calculation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Windowed RMS signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">signal</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span> <span class="o">/</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">))</span></div>



<div class="viewcode-block" id="calculate_rms">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.calculate_rms">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_rms</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates RMS features for each channel using non-overlapping windows.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data: 2D numpy array of EMG data (channels, samples).</span>
<span class="sd">        window_size: Size of the window for RMS calculation.</span>
<span class="sd">        verbose: Whether to print progress.</span>
<span class="sd">    Returns:</span>
<span class="sd">        rms_features: 2D numpy array of RMS features (channels, windows).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;| Calculating RMS features...&quot;</span><span class="p">)</span>
    <span class="n">n_channels</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">n_windows</span> <span class="o">=</span> <span class="n">n_samples</span> <span class="o">//</span> <span class="n">window_size</span>
    <span class="n">rms_features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">n_windows</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_channels</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_windows</span><span class="p">):</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">ch</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">window_size</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">window_size</span><span class="p">]</span>
            <span class="n">rms_features</span><span class="p">[</span><span class="n">ch</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">window</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">rms_features</span>  <span class="c1"># Shape (n_channels, n_windows)</span></div>



<div class="viewcode-block" id="downsample">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.downsample">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">downsample</span><span class="p">(</span><span class="n">emg_data</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">target_fs</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Downsamples the EMG data to the target sampling rate.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        emg_data: 2D numpy array of shape (num_channels, num_samples).</span>
<span class="sd">        sampling_rate: Sampling rate of the original EMG data.</span>
<span class="sd">        target_fs: Target sampling rate for downsampling.</span>

<span class="sd">    Returns:</span>
<span class="sd">        downsampled_data: 2D numpy array of shape (num_channels, downsampled_samples).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute the downsampling factor</span>
    <span class="n">downsample_factor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sampling_rate</span> <span class="o">/</span> <span class="n">target_fs</span><span class="p">)</span>

    <span class="c1"># Downsample the data by taking every nth sample</span>
    <span class="n">downsampled_data</span> <span class="o">=</span> <span class="n">emg_data</span><span class="p">[:,</span> <span class="p">::</span><span class="n">downsample_factor</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">downsampled_data</span></div>



<div class="viewcode-block" id="common_average_reference">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.common_average_reference">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">common_average_reference</span><span class="p">(</span><span class="n">emg_data</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies Common Average Referencing (CAR) to the multi-channel EMG data.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        emg_data: 2D numpy array of shape (num_channels, num_samples).</span>

<span class="sd">    Returns:</span>
<span class="sd">        car_data: 2D numpy array after applying CAR (same shape as input).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;| Subtracting common average reference&quot;</span><span class="p">)</span>
    <span class="c1"># Compute the common average (mean across all channels at each time point)</span>
    <span class="n">common_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">emg_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Shape: (num_samples,)</span>

    <span class="c1"># Subtract the common average from each channel</span>
    <span class="n">car_data</span> <span class="o">=</span> <span class="n">emg_data</span> <span class="o">-</span> <span class="n">common_avg</span>  <span class="c1"># Broadcast subtraction across channels</span>

    <span class="k">return</span> <span class="n">car_data</span></div>



<div class="viewcode-block" id="envelope_extraction">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.envelope_extraction">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">envelope_extraction</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;hilbert&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts the envelope of the EMG signal using the Hilbert transform.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data: 2D numpy array of EMG data (channels, samples).</span>
<span class="sd">        method: Method for envelope extraction (&#39;hilbert&#39; or other).</span>

<span class="sd">    Returns:</span>
<span class="sd">        envelope: 2D numpy array of the envelope (channels, samples).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;hilbert&#39;</span><span class="p">:</span>
        <span class="n">analytic_signal</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">envelope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">analytic_signal</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported method for envelope extraction.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">envelope</span></div>



<div class="viewcode-block" id="process_emg_pipeline">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.process_emg_pipeline">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">process_emg_pipeline</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">lowcut</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">highcut</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processing steps to match the CNN-ECA methodology</span>
<span class="sd">    https://pmc.ncbi.nlm.nih.gov/articles/PMC10669079/</span>
<span class="sd">    Input data is assumed to have shape (N_channels, N_samples)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data: 2D numpy array of EMG data (channels, samples).</span>
<span class="sd">        lowcut: Low cutoff frequency for the bandpass filter.</span>
<span class="sd">        highcut: High cutoff frequency for the bandpass filter.</span>
<span class="sd">        order: Order of the Butterworth filter.</span>
<span class="sd">        window_size: Window size for RMS calculation.</span>
<span class="sd">        verbose: Whether to print progress.</span>

<span class="sd">    Returns:</span>
<span class="sd">        smoothed: 2D numpy array of processed EMG data (channels, samples).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">emg_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;amplifier_data&#39;</span><span class="p">]</span>  <span class="c1"># Extract EMG data</span>
    <span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;frequency_parameters&#39;</span><span class="p">][</span><span class="s1">&#39;board_dig_in_sample_rate&#39;</span><span class="p">])</span>  <span class="c1"># Extract sampling rate</span>

    <span class="c1"># Overwrite the first and last second of the data with 0 to remove edge effects</span>
    <span class="c1"># emg_data[:, :sample_rate] = 0.0</span>
    <span class="n">emg_data</span><span class="p">[:,</span> <span class="o">-</span><span class="n">sample_rate</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Just first second</span>

    <span class="c1"># Apply bandpass filter</span>
    <span class="n">bandpass_filtered</span> <span class="o">=</span> <span class="n">filter_emg</span><span class="p">(</span><span class="n">emg_data</span><span class="p">,</span> <span class="s1">&#39;bandpass&#39;</span><span class="p">,</span> <span class="n">lowcut</span><span class="p">,</span> <span class="n">highcut</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

    <span class="c1"># Rectify</span>
    <span class="c1"># rectified = rectify_emg(bandpass_filtered)</span>
    <span class="n">rectified</span> <span class="o">=</span> <span class="n">bandpass_filtered</span>

    <span class="c1"># Apply Smoothing</span>
    <span class="c1"># smoothed = window_rms(rectified, window_size=window_size)</span>
    <span class="n">smoothed</span> <span class="o">=</span> <span class="n">envelope_extraction</span><span class="p">(</span><span class="n">rectified</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;hilbert&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">smoothed</span></div>



<div class="viewcode-block" id="sliding_window">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.sliding_window">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sliding_window</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">step_size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the data into overlapping windows.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data: 2D numpy array of shape (channels, samples).</span>
<span class="sd">        window_size: Window size in number of samples.</span>
<span class="sd">        step_size: Step size in number of samples.</span>

<span class="sd">    Returns:</span>
<span class="sd">        windows: List of numpy arrays, each representing a window of data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_channels</span><span class="p">,</span> <span class="n">num_samples</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">windows</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_samples</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step_size</span><span class="p">):</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">]</span>
        <span class="n">windows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">windows</span></div>



<div class="viewcode-block" id="apply_pca">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.apply_pca">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">apply_pca</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">num_components</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies PCA to reduce the number of EMG channels to the desired number of components.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data: 2D numpy array of EMG data (channels, samples) -&gt; (128, 500,000).</span>
<span class="sd">        num_components: Number of principal components to reduce to (e.g., 8).</span>

<span class="sd">    Returns:</span>
<span class="sd">        pca_data: 2D numpy array of reduced EMG data (num_components, samples).</span>
<span class="sd">        explained_variance_ratio: Percentage of variance explained by each of the selected components.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Step 1: Standardize the data across the channels</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
    <span class="n">features_std</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># Standardizing along the channels</span>

    <span class="c1"># Step 2: Apply PCA</span>
    <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">num_components</span><span class="p">)</span>
    <span class="n">pca_data</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">features_std</span><span class="p">)</span>  <span class="c1"># Apply PCA on the transposed data</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Original shape:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PCA-transformed data shape:&quot;</span><span class="p">,</span> <span class="n">pca_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Step 3: Get the explained variance ratio (useful for understanding how much variance is retained)</span>
    <span class="n">explained_variance_ratio</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span>

    <span class="k">return</span> <span class="n">pca_data</span><span class="p">,</span> <span class="n">explained_variance_ratio</span></div>



<div class="viewcode-block" id="z_score_norm">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.z_score_norm">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">z_score_norm</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply z-score normalization to the input data.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data: 2D numpy array of shape (channels, samples).</span>

<span class="sd">    Returns:</span>
<span class="sd">        normalized_data: 2D numpy array of shape (channels, samples) after z-score normalization.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">normalized_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">std</span>
    <span class="k">return</span> <span class="n">normalized_data</span></div>



<span class="c1"># RMS (Root Mean Square)</span>
<div class="viewcode-block" id="compute_rms">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.compute_rms">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_rms</span><span class="p">(</span><span class="n">emg_window</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the RMS of a given EMG window.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        emg_window (np.ndarray): 1D numpy array representing the EMG window.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: RMS value of the EMG window.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">emg_window</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span></div>



<div class="viewcode-block" id="compute_grid_average">
<a class="viewcode-back" href="../../../intan_api/intan.processing.html#intan.processing._filters.compute_grid_average">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_grid_average</span><span class="p">(</span><span class="n">emg_data</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the average of the EMG grids according to the grid spacing. For example, a spacing of 8 means that</span>
<span class="sd">    channels 1, 9, 17, etc. will be averaged together to form the first grid, and so on.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        emg_data (np.ndarray): 2D numpy array of shape (num_channels, num_samples).</span>
<span class="sd">        grid_spacing (int): Number of channels to average together.</span>
<span class="sd">        axis (int): Axis along which to compute the grid averages.</span>

<span class="sd">    Returns:</span>
<span class="sd">        grid_averages (np.ndarray): 2D numpy array of shape (num_grids, num_samples).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_channels</span><span class="p">,</span> <span class="n">num_samples</span> <span class="o">=</span> <span class="n">emg_data</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">num_grids</span> <span class="o">=</span> <span class="n">num_channels</span> <span class="o">//</span> <span class="n">grid_spacing</span>
    <span class="n">grid_averages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_grids</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_grids</span><span class="p">):</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">grid_spacing</span>
        <span class="n">end_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">grid_spacing</span>
        <span class="n">grid_averages</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">emg_data</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">grid_averages</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Jonathan Shulgach.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>